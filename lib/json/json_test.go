package json_test

import (
	"testing"

	"github.com/canonical/starlark/lib/json"
	"github.com/canonical/starlark/starlark"
	"github.com/canonical/starlark/startest"
)

func TestModuleSafeties(t *testing.T) {
	for name, value := range json.Module.Members {
		builtin, ok := value.(*starlark.Builtin)
		if !ok {
			continue
		}

		if safety, ok := (*json.Safeties)[name]; !ok {
			t.Errorf("builtin json.%s has no safety declaration", name)
		} else if actual := builtin.Safety(); actual != safety {
			t.Errorf("builtin json.%s has incorrect safety: expected %v but got %v", name, safety, actual)
		}
	}

	for name, _ := range *json.Safeties {
		if _, ok := json.Module.Members[name]; !ok {
			t.Errorf("safety declared for non-existent builtin json.%s", name)
		}
	}
}

func TestJsonEncodeSteps(t *testing.T) {
}

func TestJsonEncodeAllocs(t *testing.T) {
}

func TestJsonDecodeSteps(t *testing.T) {
}

func TestJsonDecodeAllocs(t *testing.T) {
	json_decode, _ := json.Module.Attr("decode")
	if json_decode == nil {
		t.Fatal("no such method: json.decode")
	}

	st := startest.From(t)
	st.RequireSafety(starlark.MemSafe)
	st.RunThread(func(thread *starlark.Thread) {
		json_document := starlark.String(`
		{
			"Int": 48879,
			"BigInt": 3825590844416,
			"Float": 1.4218e-1,
			"Bool": true,
			"Null": null,
			"Empty list": [],
			"Tuple": [ 1, 2 ]	
		}`)

		for i := 0; i < st.N; i++ {
			result, err := starlark.Call(thread, json_decode, starlark.Tuple{json_document}, nil)
			if err != nil {
				st.Error(err)
			}
			st.KeepAlive(result)
		}
	})
}

func TestJsonIndentSteps(t *testing.T) {
}

func TestJsonIndentAllocs(t *testing.T) {
	st := startest.From(t)

	obj := starlark.String(`{"l":[[[[[[{"i":10,"n":null}]]]]]]}`)
	fn := json.Module.Members["indent"]
	st.RequireSafety(starlark.MemSafe)
	st.RunThread(func(thread *starlark.Thread) {
		for i := 0; i < st.N; i++ {
			result, err := starlark.Call(thread, fn, starlark.Tuple{obj}, nil)
			if err != nil {
				st.Error(err)
			}
			st.KeepAlive(result)
		}
	})
}
